import {
  Feature_default as Feature_default3,
  createGeometry,
  createRenderFeature,
  transformGeometryWithOptions
} from "./chunk-TLCAZXHC.js";
import {
  Feature_default,
  Feature_default2
} from "./chunk-F2YMZTCR.js";
import "./chunk-N5DILE6P.js";
import "./chunk-OIUIQEKQ.js";
import {
  deflateCoordinatesArray,
  deflateMultiCoordinatesArray,
  getLayoutForStride
} from "./chunk-JKBWHLKN.js";
import "./chunk-DPUDTV6U.js";
import {
  get
} from "./chunk-56S5ZIRH.js";
import "./chunk-QFCIXVZ3.js";
import {
  abstract
} from "./chunk-7ZT6NKHI.js";
import {
  isEmpty
} from "./chunk-6PJZILPY.js";

// node_modules/ol/format/JSONFeature.js
var JSONFeature = class extends Feature_default3 {
  constructor() {
    super();
  }
  getType() {
    return "json";
  }
  readFeature(source, options) {
    return this.readFeatureFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readFeatures(source, options) {
    return this.readFeaturesFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readFeatureFromObject(object, options) {
    return abstract();
  }
  readFeaturesFromObject(object, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return this.readGeometryFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readGeometryFromObject(object, options) {
    return abstract();
  }
  readProjection(source) {
    return this.readProjectionFromObject(getObject(source));
  }
  readProjectionFromObject(object) {
    return abstract();
  }
  writeFeature(feature, options) {
    return JSON.stringify(this.writeFeatureObject(feature, options));
  }
  writeFeatureObject(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return JSON.stringify(this.writeFeaturesObject(features, options));
  }
  writeFeaturesObject(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return JSON.stringify(this.writeGeometryObject(geometry, options));
  }
  writeGeometryObject(geometry, options) {
    return abstract();
  }
};
function getObject(source) {
  if (typeof source === "string") {
    const object = JSON.parse(source);
    return object ? object : null;
  }
  if (source !== null) {
    return source;
  }
  return null;
}
var JSONFeature_default = JSONFeature;

// node_modules/ol/format/GeoJSON.js
var GeoJSON = class extends JSONFeature_default {
  constructor(options) {
    options = options ? options : {};
    super();
    this.dataProjection = get(
      options.dataProjection ? options.dataProjection : "EPSG:4326"
    );
    if (options.featureProjection) {
      this.defaultFeatureProjection = get(options.featureProjection);
    }
    if (options.featureClass) {
      this.featureClass = options.featureClass;
    }
    this.geometryName_ = options.geometryName;
    this.extractGeometryName_ = options.extractGeometryName;
    this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  readFeatureFromObject(object, options) {
    let geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    const geometry = readGeometryInternal(geoJSONFeature["geometry"], options);
    if (this.featureClass === Feature_default2) {
      return createRenderFeature(
        {
          geometry,
          id: geoJSONFeature["id"],
          properties: geoJSONFeature["properties"]
        },
        options
      );
    }
    const feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && geoJSONFeature["geometry_name"]) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(createGeometry(geometry, options));
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  }
  readFeaturesFromObject(object, options) {
    const geoJSONObject = object;
    let features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      const geoJSONFeatureCollection = object;
      features = [];
      const geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        const featureObject = this.readFeatureFromObject(
          geoJSONFeatures[i],
          options
        );
        if (!featureObject) {
          continue;
        }
        features.push(featureObject);
      }
    } else {
      features = [this.readFeatureFromObject(object, options)];
    }
    return features.flat();
  }
  readGeometryFromObject(object, options) {
    return readGeometry(object, options);
  }
  readProjectionFromObject(object) {
    const crs = object["crs"];
    let projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get("EPSG:" + crs["properties"]["code"]);
      } else {
        throw new Error("Unknown SRS type");
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  }
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    const object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    const id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  }
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  }
  writeGeometryObject(geometry, options) {
    return writeGeometry(geometry, this.adaptOptions(options));
  }
};
function readGeometryInternal(object, options) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry(object);
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry(
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry(object);
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry(
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry(
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry(
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return geometry;
}
function readGeometry(object, options) {
  const geometryObject = readGeometryInternal(object, options);
  return createGeometry(geometryObject, options);
}
function readGeometryCollectionGeometry(object, options) {
  const geometries = object["geometries"].map(
    function(geometry) {
      return readGeometryInternal(geometry, options);
    }
  );
  return geometries;
}
function readPointGeometry(object) {
  const flatCoordinates = object["coordinates"];
  return {
    type: "Point",
    flatCoordinates,
    layout: getLayoutForStride(flatCoordinates.length)
  };
}
function readLineStringGeometry(object) {
  var _a;
  const coordinates = object["coordinates"];
  const flatCoordinates = coordinates.flat();
  return {
    type: "LineString",
    flatCoordinates,
    ends: [flatCoordinates.length],
    layout: getLayoutForStride(((_a = coordinates[0]) == null ? void 0 : _a.length) || 2)
  };
}
function readMultiLineStringGeometry(object) {
  var _a, _b;
  const coordinates = object["coordinates"];
  const stride = ((_b = (_a = coordinates[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 2;
  const flatCoordinates = [];
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);
  return {
    type: "MultiLineString",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function readMultiPointGeometry(object) {
  var _a;
  const coordinates = object["coordinates"];
  return {
    type: "MultiPoint",
    flatCoordinates: coordinates.flat(),
    layout: getLayoutForStride(((_a = coordinates[0]) == null ? void 0 : _a.length) || 2)
  };
}
function readMultiPolygonGeometry(object) {
  var _a, _b;
  const coordinates = object["coordinates"];
  const flatCoordinates = [];
  const stride = ((_b = (_a = coordinates[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b[0].length) || 2;
  const endss = deflateMultiCoordinatesArray(
    flatCoordinates,
    0,
    coordinates,
    stride
  );
  return {
    type: "MultiPolygon",
    flatCoordinates,
    ends: endss,
    layout: getLayoutForStride(stride)
  };
}
function readPolygonGeometry(object) {
  var _a, _b;
  const coordinates = object["coordinates"];
  const flatCoordinates = [];
  const stride = (_b = (_a = coordinates[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b.length;
  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);
  return {
    type: "Polygon",
    flatCoordinates,
    ends,
    layout: getLayoutForStride(stride)
  };
}
function writeGeometry(geometry, options) {
  geometry = transformGeometryWithOptions(geometry, true, options);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(
        geometry,
        options
      );
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(
        geometry,
        options
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(
        geometry,
        options
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(
        geometry,
        options
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(
        geometry,
        options
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(
        geometry,
        options
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        geometry,
        options
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON_default = GeoJSON;
export {
  GeoJSON_default as default
};
//# sourceMappingURL=ol_format_GeoJSON__js.js.map
